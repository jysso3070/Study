2019-1 게임서버 중간

1. 많은 동시 접속 인원을 처리하기 위해 온라인게임서비스하는 서버에서 여러정책을 채용한다 각 정책에 대한
설명 중 옳은 것에 대해 OX
  a. 샤딩을 하는 이유는 쾌적한 게임플레이는 위해 서버의 인구 밀도를 줄이기 위해서 이다 - X
  b. 샤딩을 할 경우 샤딩의 개수 만큼의 별도 DB가 필요하다 - O
  c. 기능별 분산을 하려할 때 이로 인한 통신 오버헤드의 증가를 고려해야한다 - O
  d. 기능별 분산을 하는 경우 어느 한 서버가 병목이 되는 것을 피하기는 힘들다 - O
  e. 접속 분할의 경우 반드시 게임에서 로그아웃을 해야 채널 이동을 할 수 있다 - X
  f. 공간 분할을 seamless로 구현하는 것이 pottal 방식으로 구현하는 것보다 쉽다 -X

2. 클라이언트와 서버 사이의 프로토콜을 고급 언어의 구조체로 정의하지 않고 메모리 블록과 내부 인덱스로
정의하는 경우가 있다, 이때 발생하는 문제점은?
	- 코드의 가독성이 떨어지고, 코드의 수정이 어려워진다.

3. 서버용 컴퓨터에서 사용되는 CPU인 XEON이나 EPYC이 일반 데스크탑 CPU보다 메모리 채널이 더 많아야 하는
이유는? 
	- 서버는 병렬처리가


4. 게임서버 프로그래밍을 할때 주의사항으로 일단 접속을 받기 시작하면 File I/O를 하지 말라는 것이 있다
그 이유는 무엇인가?
	- 파일 io의 경우 대기 시간이 길어 서버에 렉이 생기고 오버헤드가 발생한다.


5. 게임버서 프로그래밍을 할때 캐릭터 레벨이 1에서 100까지 라면 이를 저장하기 위해 int 를 사용하지 말고 char을 사용
하는것이 좋다 그 이유는?

6. 다음은 소켓스레드 I/O모델 서버의 대략적인 구조이다 ()에 들어갈 내용

do_io(mysock){
    while (true) {
        (   빈칸      ) {
            패킷처리;  
     }
}


main()
{
   while (!shutdown){
	new_sock = accept(sock, &addr, &len);
	thread t = thread{  do_io, new_sock} ;
    }

]



8. process와 thread의 차이점으로 통신 오버헤드를 들 수 있다. process사이의 통신이 thread 사이의통신보다 부하가
큰 이유는무엇인가?


9. OX문제
  a. overlapped I/O는 달리 asynchronous I/O라고도 불린다 - O
  b. LINUX에서는 epoll함수를 통해서 overlapped 스타일의 I/O모델을 구현할 수 있다. - O
  c. overlapped 에서는 하나의 소켓에 대해서 여러개의 send를 동시에 처리할 수 없다 - X
  d. overlapped 에서는 데이터 전송을 위해 send 대신 WSASend api를 반드시 사용해야 한다 - O
  e. overlapped 에 한번 사용된 오버랩 구조체는 재사용이 불가능하다 - X
  f. overlapped 을 통한 send나 recv 요청은 반드시 즉시 리턴한다 - O
  g. overlaaped 을 통해 데이터 수신을 할 경우 Recv함수가 리턴하면 다시 recv할 수 있다 - X


10. 틀린설명 모두 고르기  a, d, e
  a. 전용 api로는 createioCompletionPort 와 RegisterThreadtoLOCP등이 있다.
  b. createIOCompletionPort에서 정의된 개수를 초과하는 스레드는 동시에 실행될 수 없다.
  c. socket연결의 강제 종료는 GetQueueCompletionport함수의 에러값을 통해서 파악한다
  d. worker thread이외의 스레드에서 WSARecv호출은 불가능 하다
  e. IOCP가 관리하는 복수의 소켓에서 WSASend는 동시에 하나만 실행되어야 한다.


11. IOCP의 GetQueueCompletionStatus함수에서 부족한 정보를 확장된 오버랩 구조체를 통해 얻는다 이때 추가로 확보
해야하는 정보에는 어떠한 것들이 있는가
	


12. OX
  a. thread사이 동기화에는 지역변수들을 사용한다 - X
  b. 싱글 코어 컴퓨터에서 멀티스레드 프로그램을 실행하면 data race가 발생하지 않는다 - X
  c. C++11의 STL 컨테이너들은 뮤텍스 만으로는 멀티스레드에서 atomic하게 동작하게 할수 없다. - X
  d. 피시에 있는 메모리는 mfence 명령을 추가하면 atomic memory처럼 사용할 수 있다. - O
  e. 피터슨 알고리즘은 블로킹 알고리즘중에 하나이다 - O
  f. CAS 연산을 HW로 구현하지 않으면 많은 논블로킹 자료구조를 구현하는 것이 불가능 하다 - O
  g. 논블로킹 알고리즘인 lcok-free알고리즘의 수행 시간은 다른 스레드의 동작에 영향을 받지않는다 - X


13. 게임 실행 시 벽이나 장애물과의 충돌 검사를 게임서버에서만 하는 것이 아니라 클라이언트에서도  해야 되는 이유는
무엇인가


15. 게임서버에서 충돌검사를 위해 클라이언트의 폴리곤 모델을 사용하는 경우가 있다 하지만 투디 지형만을 사용할 경우
cell방식의 충돌검사도 많이 사용하는데 cell방식의 이점은 무엇인가

16. 게임서버에서 목표물을 향해 이동할때 에이스타 알고리즘을 사용하여 길 찾기를 한다 이때 찾은 길의 path list를 저장하지
않고 매번 이동시 마다 다시 길 찾기를 하는 이유는 무엇인가?














